#summary Dumping ground for ideas about new client libs
#labels Phase-Design

= Introduction =

We want to make a standard data exchange format between clients and agents, you wont *have* to use it but it will go a long way towards writing generic clients.

Today almost every agent and client impliments their own little weird exchange of info and data, this makes it hard to do generic clients, other languages etc.

The idea is that we could write a CLI tool like:

{{{
$ mc-call-agent --agent exim --action setsender --data msgid=1-2-3-4 --data sender="foo@bar"
}}}

The output should then be a print of each host response in a human parsable format - even pp output is parsable.

With this in place we'd be able to make generic web based and cli based tools easier, and ultimately make it easier to write task specific clients too.

= Data Structures =
== Requests ==
A request for:

  * The _exim_ agent
  * It's _setsender_ action that expects msgid and sender set

The following will be in the _:body_ of the [MessageFormat normal messages]

{{{
{
 :agent => "exim",
 :action => "setsender",
 :data => {:msgid => "1-2-3-4",
           :sender => "foo@bar"}
}
}}}


== Replies ==
The reply that will come in the _:body_ will again be a hash, the hash would look something like this:

{{{
{
 :statuscode => 0,
 :statusmessage => "OK",
 :data => anything
}
}}}

Some status code ideas could be:

||0||OK||
||1||Unknown action||
||2||Missing data||
||3||Invalid data||
||4||Other error||

The _:statusmessage_ would just be a human parsable representation of above that in the case of 2, 3 and 4 might give more information about whats going on.

The _:data_ would be application specific, for example the _puppetd_ agent will return a _false_ if it was asked to disable an already disabled agent, this should be in the _:data_ and not be an error in the status messages.

= Sample Usage =
How might this look in use? The code snippets below show a few sample use cases.

{{{
exim = Client.new("exim", options)
exim.discover

data = exim.setsender(:msgid => "1-2-3-4", :sender => "foo@bar"}
stats = exim.stats
}}}

In this case the requests that gets created will be for the exim agent, it will pre-discover and you can just call any remote action by name, we'll need to (ab)use the _method`_`missing_ hooks to achieve this.

The returned _data_ will be a Array of responses from each host, if even one of them returns anything but _0_ then an exception will be raised with the :statusmessage in it.

The _stats_ method will have a normal _MCollective::Client_ style stats for the most recent request.

{{{
exim = Client.new("exim", options)
exim.discover

stats = exim.setsender(:msgid => "1-2-3-4", :sender => "foo@bar"} do |resp|
   # do stuff per response
end
}}}

In this use case the _resp_ would simply be a copy of the main response, you'd have access to all the various properties of it such as sender and so forth, you'd be able to do your own handling of errors etc, it's essentially the same as _MCollective::Client#req_

= Questions =
  * Should the data block be a special object - maybe an OpenStruct - so we can easily access the response properties?  A hash would do find too but be less intuitive.
  * Should we be using symbols here or just strings, symbols is a rubyism we might find it easier later to support other languages?
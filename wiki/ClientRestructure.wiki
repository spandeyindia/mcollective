#summary Dumping ground for ideas about new client libs
#labels Phase-Design

= Introduction =

We want to make a standard data exchange format between clients and agents, you wont *have* to use it but it will go a long way towards writing generic clients.

Today almost every agent and client impliments their own little weird exchange of info and data, this makes it hard to do generic clients, other languages etc.

Some inspiration can be found in [http://www.linode.com/api/ Linode's API] and the [http://github.com/rick/linode Ruby Client for it].

The idea is that we could write a CLI tool like:

{{{
$ mc-call-agent --agent exim --action setsender --data msgid=1-2-3-4 --data sender="foo@bar"
}}}

The output should then be a print of each host response in a human parsable format - even pp output is parsable.

With this in place we'd be able to make generic web based and cli based tools easier, and ultimately make it easier to write task specific clients too.

= Sample Usage =
How might this look in use in client code? The code snippets below show a few sample use cases.

{{{
exim = Client.new("exim", options)
exim.discover

data = exim.setsender(:msgid => "1-2-3-4", :sender => "foo@bar"}
stats = exim.stats
}}}

In this case the requests that gets created will be for the exim agent, it will pre-discover and you can just call any remote action by name, we'll need to (ab)use the _method`_`missing_ hooks to achieve this.

The returned _data_ will be a Array of responses from each host, if even one of them returns anything but _0_ then an exception will be raised with the :statusmessage in it.

The _stats_ method will have a normal _MCollective::Client_ style stats for the most recent request.

This use case is used extensively to enable the kind of application in [http://screenr.com/yoU] it makes it much easier to just interact with your collective as if it's one big object.

{{{
exim = Client.new("exim", options)
exim.discover

stats = exim.setsender(:msgid => "1-2-3-4", :sender => "foo@bar"} do |resp|
   # do stuff per response
end
}}}

In this use case the _resp_ would simply be a copy of the main response, you'd have access to all the various properties of it such as sender and so forth, you'd be able to do your own handling of errors etc, it's essentially the same as _MCollective::Client#req_

= Data Structures =
We expect there to be 2 classes that wrap the data below into the above usage, so all requests and responses that adhere to these standards will use those.

== Requests ==
A request for:

  * The _exim_ agent
  * It's _setsender_ action that expects msgid and sender set

The following will be in the _:body_ of the [MessageFormat normal messages]

{{{
{
 :agent => "exim",
 :action => "setsender",
 :data => {:msgid => "1-2-3-4",
           :sender => "foo@bar"}
}
}}}


== Replies ==
The reply that will come in the _:body_ will again be a hash, the hash would look something like this:

{{{
{
 :statuscode => 0,
 :statusmessage => "OK",
 :data => {:status => 0,
           :message => "message 1-2-3-4 has been modified"}
}

{
 :statuscode => 0,
 :statusmessage => "OK",
 :data => {:status => 1,
           :message => "no message with id 1-2-3-4 found"}
}

}}}

Some status code ideas could be:

||0||OK||
||1||Unknown action||
||2||Missing data||
||3||Invalid data||
||4||Other error||

The _:statusmessage_ would just be a human parsable representation of above that in the case of 2, 3 and 4 might give more information about whats going on.

The _:data_ would be application specific, for example here the application decides to return it's own status and message, the request in the 2nd structure didn't fail due to a hard error but the agent still wanted to let us know it didn't take any action.


= Introspection =
I'd like the agents to be able to expose their needs somehow, to be able to make a web system to call any and all agents the websystem should be able to figure out what fields to present to a user.

This might not really fit in with this specific task but worth keeping in mind, certainly to be able to do introspection on agents the agents should be available on the local drive of the client, we wouldn't want to ask the entire network to send back introspection information.

= Questions =
  * Should the data block be a special object - maybe an OpenStruct - so we can easily access the response properties?  A hash would do find too but be less intuitive.  We could support both by using the _`[``]`_ and _method_missing_ tricks to expose the same data in the response objects.
  * Should we be using symbols here or just strings, symbols is a rubyism we might find it easier later to support other languages?
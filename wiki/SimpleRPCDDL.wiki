#summary SimpleRPC Data Description Language
#labels Phase-Implementation,SimpleRPC

= Introduction =

As with other remote procedure invocation systems SimpleRPC has a DDL that defines what remote methods are available, what inputs they take and what outputs they generate.

In addition to the usual procedure definitions we also keep meta data about author, versions, license and other key data points.

The DDL is used in various scenarios:

 * The user can access it in the form of a human readable help page
 * User interfaces can access it in a way that facilitate auto generation of user interfaces
 * The RPC client auto configures and use appropriate timeouts in waiting for responses
 * Before sending a call over the network inputs get validated so we do not send unexpected data to remote nodes.
 * Module repositories can use the meta data to display a standard view of available modules to assist a user in picking the right ones.

= Examples =
We'll start with a few examples as I think it's pretty simple what they do, and later on show what other permutations are allowed for defining inputs and outputs.

The typical service agent is a good example, it has various actions that all more or less take the same input.  All but status would have almost identical language.

== Meta Data ==
First we need to define the meta data for the agent itself:

{{{
metadata :name        => "SimpleRPC Service Agent",
         :description => "Agent to manage services using the Puppet service provider", 
         :author      => "R.I.Pienaar",
         :license     => "GPLv2",
         :version     => "1.1",
         :url         => "http://mcollective-plugins.googlecode.com/",
         :timeout     => 60
}}}

It's fairly obvious what these all do, _:timeout_ is how long the MCollective daemon will let the threads run.

== Actions, Input and Output ==
Defining inputs and outputs is the hardest part, below first the _status_ action:

{{{
action "status", :description => "Gets the status of a service" do
    input :service, 
          :prompt      => "Service Name",
          :description => "The service to get the status for",
          :type        => :string,
          :validation  => '^[a-zA-Z\-_\d]+$',
          :optional    => false,
          :maxlength   => 30

    output "status",
          :description => "The status of service",
          :display_as  => "Service Status"
end
}}}

As you see we can define all the major components of input and output parameters.  _:type_ can be one of various values and each will have different parameters, more on that later.

Finally the service agent has 3 almost identical actions - _start_, _stop_ and _restart_ - below we use a simple loop to define them all in one go.

{{{
["start", "stop", "restart"].each do |act|
    action act, :description => "#{act.capitalize} a service" do
        input :service, 
              :prompt      => "Service Name",
              :description => "The service to #{act}",
              :type        => :string,
              :validation  => '^[a-zA-Z\-_\d]+$', 
              :optional    => false,
              :maxlength   => 30

        output "status",
              :description => "The status of service after #{act}",
              :display_as  => "Service Status"
    end
end
}}}

All of this code just goes into a file, no special class or module bits needed, just save it as _service.ddl_ in the same location as the _service.rb_.

Importantly you do not need to have the _service.rb_ on a machine to use the DDL, this means on machines that are just used for running client programs you can just drop the _.ddl_ files into the agents directory.

= Optional Inputs =
The input block has a mandatory _:optional_ field, when true it would be ok if a client attempts to call the agent without this input supplied.  If it is supplied though it will be validated.

= Types of Input =
As you see above the input block has _:type_ option, types can be _:string_ or _:list_ today, we intend to expand this to other validations.

== :string type ==
The string type validates initially that the input is infact a String, then it validates the length of the input and finally matches the supplied Regular Expression.

Both _:validation_ and _:maxlength_ are required arguments for the string type of input.

== :list type ==
List types provide a list of valid options and only those will be allowed, see an example below:

{{{
input :action, 
      :prompt      => "Service Action",
      :description => "The action to perform",
      :type        => :list,
      :optional    => false,
      :list        => ["stop", "start", "restart"]
}}}

In user interfaces this might be displayed as a drop down list selector or another kind of menu.
